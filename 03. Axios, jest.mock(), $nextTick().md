# testing Axios

Что тестируем:
- axios- вызывается, но не нативный(этого избегаем), а его mock.
- mock аксиоса возвращает промис
- в результате изменяется data().

## При использовании jest.mock() код начинаем с обнуления перед каждым тестом
  let wrapper
  beforeEach(() => {
    wrapper = shallowMount(App)
    jest.resetModules()
    jest.clearAllMocks()
  })
  

#1. заглушка для axios, ничего не возвращающая.
    methods: {
      async onSubmit(w) {
        let response = await axios.get(`https://jsonplaceholder.typicode.com/posts?q=${w}`)
        this.results = response.data
      }
    }

import { mount } from '@vue/test-utils'
import App from '../App'
import axios from 'axios'

jest.mock('axios', () => ({ get: jest.fn() })        //заглушка для axios, ничего не возвращающая

it('Вызываем axios.get = ', () => {
  let wrapper = mount(App)
  wrapper.vm.onSubmit('10')        //запускаем нативный onSubmit()
  expect(axios.get).toBeCalledWith('https://jsonplaceholder.typicode.com/posts?q=10')  //axios- вызывается
})



#2. Заглушка для axios, возвращающая непустой факовый Promise.
https://jestjs.io/docs/en/mock-functions (!)

  import axios from 'axios'
  export default {
    data: () => ({
      results: ''
    }),
    methods: {
      async getNotifications() {
        await axios.get('/notifications.json')
          // .then(resp => console.log('rr ====', resp.data))
          .then(resp => this.results = resp.data)
      }
    },
    mounted() {
      this.getNotifications()
    }
  }

test:
import { mount } from '@vue/test-utils';
import App from '../../src/App'
import axios from 'axios'      // axios здесь нужен, но он перетирается заглушкой.

jest.mock('axios', () => {   //заглушка аксиоса будет возвращать именно ПРОМИС (второй аналогичный пример - чуть ниже)
  return {
    get: () => Promise.resolve({data: 'kola'})
  }
})

describe('App-axios', () => {
  it('renders a notification', () => {
    let wrapper = mount(App)
    setTimeout(() => {
      expect(wrapper.vm.results).toEqual('kola')
      done()        //обязательно(!)
    }, 0)

  })
})

==>>
при запуске теста 'поднимаем' тестируемый компонент,
mounted() в момент подъема компонента запускает функцию getNotifications,
и здесь требуется setTimeout(!)
axios перетирается за счет заглушки,
и в this.results поступает 'kola'.




#3. Promise в заглушке для get в заглушке аксиоса дополнительно оборачиваем в jest.fn().
jest.mock('axios', () => ({
  get: jest.fn(() => Promise.resolve({ data: 'kola' })) 
}))  
- так тоже работает, но корысть непонятна.





#4.
Тестируем компонент,
дата аксиоса поступает из заглушки аксиоса.
Тестируемый компонент- без правок.

(Тестирование асинхронной логики-
https://vue-test-utils.vuejs.org/ru/guides/testing-async-components.html)

//тест
import {mount, shallowMount, RouterLinkStub} from '@vue/test-utils'
import AppNotifications from '../AppNotifications'

jest.mock('axios', () => {
  return {
    get: () => Promise.resolve({
      data: {
        data: [                    //<<== структура получаемого по axios ответа.
          {
            id: 1,
            body: 'First'
          },
          {
            id: 2,
            body: 'Second'
          }
        ]
      }
    }),
    post() {                       //POST-request.
      return Promise.resolve()
    }
  }
})

ИЛИ
jest.mock('axios', () => {
  return {
    get() {
      return Promise.resolve({
        data: [
         .....
        ]
      })
    }
  }
})


describe('AppNotifications', () => {
  it('renders a list of notifications', (done) => {    //done - вставить обязательно(!)
    let wrapper = mount(AppNotifications)
    setTimeout(() => {
      console.log('wrapper.html()-5 = ', wrapper.html())
      let items = wrapper.findAll('li')
      expect(items.at(0).text()).toContain('First')
      expect(items.at(1).text()).toContain('Second')
      done()        //обязательно(!)
    }, 0)


    //wrapper.vm.$nextTick(() => {               //Здесь- не срабатывает, но в setInterval.md - СРАБАТЫВАЕТ(!) 
    //   console.log('wrapper.html() = ', wrapper.html())
    //   done()
    //})


//NB!
$nextTick(() срабатывает только тогда, 
когда мы принудительно запускаем getNotifications(), содержащую аксиос, "по клику",
wrapper.find('a').trigger('click') 

, а не тестируем аксиос, запускаемый by mounted().

ИНАЧЕ надо использовать setTimeout().

См. Тестирование асинхронной логики-
https://vue-test-utils.vuejs.org/ru/guides/testing-async-components.html

  })
})




.............................

4/тестируем асинхронную функцию (семинар Vue-school).

А. Код
methods: {
    async fetchData() {
      const response = await fetch("GO")
      this.data = response.data
    }
  }
  

Б. тестируем fetchData()

test('fetchData', async () => {
    const fetchMock = jest.fn().mockResolvedValue('DATA')
    // or:  const jsonMock = jest.fn().mockImplementation(() => Promise.resolve('DATA'));

    // const jsonMock = jest.fn().mockImplementation(() => 'DATA')
    // or:  const jsonMock = jest.fn(() => 'DATA')
   
    window.fetch = fetchMock                           //заменили нативный fetch() by подставой
    
    await wrapper.vm.fetchData()                       //запустили проверяемую функцию
    expect(wrapper.vm.data).toBe('DATA')               //получили правильный результат
})


.................................

## Где храним mock для axios.
#1.// test/__mocks__/axios.js

module.exports = {
  get: jest.fn(() => Promise.resolve({ data: [3] }))
}

Jest АВТОМАТИЧЕСКИ(!) применит подстановочный объект во всех наших тестах.
Но имя модуля, который мокким, должно СОВПАДАТЬ с именем файла(!).




#2. или непосредственно в тесте
NB! Заявленный jest.mock() хоть в конце кода- всегда "поднимается" в его начало.

jest.mock('axios', () => ({
  get: jest.fn(() => Promise.resolve({ data: 3 }))
}))

expect(axios.get).toBeCalledWith('https://jsonplaceholder.typicode.com/posts?q=an')



# 3.NB!
Вызванность обманки аксиоса продолжает работать и в нижеследующих тестах!
Поэтому, что бы это обнулить, надо сделать

jest.clearAllMocks()

а еще лучше делать

beforeEach(() => {
  jest.resetModules();
  jest.clearAllMocks();
})





